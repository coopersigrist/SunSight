import pandas as pd
import numpy as np
import scipy
import seaborn as sns
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D
from matplotlib.patches import Patch
import pgeocode
import plotly.graph_objects as go
import plotly.io as pio
import plotly.offline as pyo
import kaleido
from decimal import Decimal
import folium as fl
import io
import os
from PIL import Image
import branca.colormap as cm
from branca.element import Template, MacroElement
from branca.colormap import linear
from mpl_toolkits.axes_grid1 import make_axes_locatable
from tqdm import tqdm

def fit_dat_and_plot(x, y, deg, label="", label_plot=False, log=False):

    # fits an arbitrary degree polynomial and then plots it
    if deg == "linear":
        deg = 1
    if deg == "quadratic":
        deg = 2
    
    if log:
        y = np.log(y)

    coeff = np.polynomial.polynomial.Polynomial.fit(x, y, deg).convert().coef
    pred = np.zeros(y.shape)
    poly_str = '%.1E' % Decimal(coeff[0])
    for i in range(deg + 1):
        pred += coeff[i] * (x ** i)
        if i > 0:
            poly_str = '%.1E' % Decimal(coeff[i]) +"x^" +str(i) +" + "  + poly_str

    if log:
        pred = np.exp(pred)

    if label_plot:
        plt.plot(x, pred, label=str(deg) + " degree polynomial best fit -- " + label, linewidth=2) 
    else: 
        plt.plot(x, pred, linewidth=6) 

    return coeff

# Creates a scatter plot as you'd expect with autogenerated title
def scatter_plot(x, y, texts=None, xlabel="", ylabel="", title=None, fit=None, label="", show=True, color="palegreen", log=False, label_fit=True, alpha=0.1, fontsize=15, avgs=False, c=None, cmap=None, legend=False):

    font = {'family' : 'DejaVu Sans',
    'weight' : 'bold',
    'size'   : 15}


    dat = pd.DataFrame()
    dat['x'] = x
    dat['y'] = y
    dat = dat.dropna(axis=0)

    if fit is not None:
        dat = dat.sort_values("x")
        max_x = max(dat["x"])
        # dat["x"] /= max_x
        if type(fit) is int:
            fit = [fit]
        for deg in fit:
                fit_dat_and_plot(dat["x"].values, dat["y"].values, deg, label, label_plot=label_fit, log=log)

    if color == '':
        plt.scatter(dat['x'], dat['y'], alpha=alpha, label=label, c=c, cmap=cmap,norm=matplotlib.colors.LogNorm())
        plt.colorbar()
        # plt.text(np.max(dat['x'])*1.15, (np.max(dat['y']) + np.min(dat['y'])) /2 + 400, "National Max", rotation=0, fontdict=font)
        plt.text(np.max(dat['x'])*1.2, ((np.max(dat['y']) + np.min(dat['y'])) /2 * 0.9), "Log Realized Potential", rotation=270, fontdict=font)
    elif color is not None:
        plt.scatter(dat['x'], dat['y'], color=color, alpha=alpha, label=label)
    else:
        plt.scatter(dat['x'], dat['y'], alpha=alpha, label=label)

    if texts is not None:
        # add labels to all points
        for (label, xi, yi) in zip(texts, x, y):
            plt.text(xi, yi*1.01, label, va='top', ha='center')

    if avgs:
        x_avg = np.mean(dat['x'])
        y_avg = np.mean(dat['y'])

        # Making lines seperating along the average of each axis
        plt.hlines(y_avg, np.min(dat['x']), np.max(dat['x']), colors='darkgray' ,linestyles='dashed', linewidth=4)
        plt.text(np.min(dat['x']), y_avg+15, "Average: " + str(np.round(y_avg, 2)), alpha=1, fontdict=font)
        plt.vlines(x_avg, np.min(dat['y']), np.max(dat['y']) - 30, colors='darkgray' ,linestyles='dashed', linewidth=4) 
        plt.text(x_avg-40, np.max(dat['y']), "Average : " + str(np.round(x_avg, 2)), alpha=1, fontdict=font)

        # Printing the percent of point in each quadrant too
        total = len(dat['x'])
        plt.text(np.min(dat['x']) - 5, np.max(dat['y']), "In quadrant: " + str(((((np.sum((dat['x'] < x_avg) * (dat['y'] > y_avg))) / total) * 1000) // 1) /10) + '%', alpha=1, fontsize=15)
        plt.text(np.min(dat['x']) - 5, np.min(dat['y']), "In quadrant: " + str(((((np.sum((dat['x'] < x_avg) * (dat['y'] < y_avg))) / total) * 1000) // 1) /10) + '%', alpha=1, fontsize=15) 
        plt.text(np.max(dat['x'])*0.8 , np.max(dat['y']), "In quadrant: " + str(((((np.sum((dat['x'] > x_avg) * (dat['y'] > y_avg))) / total) * 1000) // 1) /10) + '%', alpha=1, fontsize=15)
        plt.text(np.max(dat['x'])*0.8 , np.min(dat['y']), "In quadrant: " + str(((((np.sum((dat['x'] > x_avg) * (dat['y'] < y_avg))) / total) * 1000) // 1) /10) + '%', alpha=1, fontsize=15) 

    plt.xticks(fontsize=fontsize)
    plt.yticks(fontsize=fontsize)
    plt.tight_layout()
    if show:
        plt.xlabel(xlabel,fontdict=font, labelpad=20)
        plt.ylabel(ylabel,fontdict=font, labelpad=20)
        if legend:
            plt.legend()
        if title is None:
            plt.title(ylabel + " versus " + xlabel, fontsize=fontsize)
        else:
            plt.title(title, fontsize=fontsize)
        plt.show()

def q_binning(vals, key, q=4, legible_label="Value"):

    cutoffs = np.append(np.quantile(vals, np.arange(0,1,1/q)), np.max(vals))
    percentiles = np.round(np.arange(0,1+1/q,1/q), 2)
    bins = []
    for i in range(len(cutoffs) - 1):
        bins.append((key, (cutoffs[i], cutoffs[i+1]), legible_label + " in " + str(percentiles[i]) + " to " + str(percentiles[i+1]) + " percentile", None))

    return bins

def complex_scatter(combined_df, x, y, xlabel, ylabel, fit=[1], title=None, bins=[], masks=[], show=True, states=None, legend=True, fontsize=15, square=False):
    '''
    Inputs:
        combined_df : DataFrame object of all saved data (or a subset thereof), at a zip code level
        x : The x axis for the plot (will be a col of combined_df)
        y : Ditto but for the y axis
        bins: A list of tuples with (key:str, range:tuple, label:str, color:str)
            - key wil denote which col we are binning on, range will determine the range that we will mask the data for
            - label will be a label for plotting, color will be the color for the scatter plot
        
        TODO Refactor and finish comment
    '''

    keys = combined_df.keys()
    corrs = []

    for (key, range, label, color) in bins:
        low, high = range
        if key in keys:
            mask1 = (low <= combined_df[key]) 
            df = combined_df[mask1] 
            mask2 = (df[key] < high)
            corr, _ = scipy.stats.pearsonr(x[mask1][mask2], y[mask1][mask2])
            corrs.append(str(np.round(corr, 2)))
            scatter_plot(x=x[mask1][mask2], y=y[mask1][mask2], fit=fit, show=False, label=label, color=color, label_fit=False, fontsize=fontsize)
        else:
            print("Key error in Complex Scatter on key:", key, " -- not a valid key for census or solar, skipping")

    for (mask, label, color) in masks:
        scatter_plot(x=x[mask], y=y[mask], fit=fit, show=False, label=label, color=color, label_fit=False, fontsize=fontsize)

    if square:
        # plt.gca().set_aspect('equal')
        plt.locator_params(axis='x', nbins=5) 
        plt.locator_params(axis='y', nbins=5) 
        plt.yticks(fontsize=fontsize/(1.5))
        plt.xticks(fontsize=fontsize/(1.5))
        plt.xlim(0, 500000000)
        plt.ylim(0, 250)
        # plt.subplots_adjust(top = 1, bottom = 0, right = 1, left = 0, 
        #     hspace = 0, wspace = 0)
        plt.margins(0.1,0.1)

        
    if show:
        plt.xlabel(xlabel, fontsize=fontsize, labelpad=20)
        plt.ylabel(ylabel, fontsize=fontsize, labelpad=20)
        if legend:
            legend_elements = [Line2D([0], [0], marker='o',color='blue', lw=4, label='Low Carbon Offset'),
                Line2D([0], [0],marker='o',  color='orange', lw=4, label='Low-Middle Carbon Offset'),
                Line2D([0], [0],marker='o',  color='green', lw=4, label='High-Middle Carbon Offset'),
                Line2D([0], [0],marker='o',  color='red', lw=4, label='High Carbon Offset')]
            legend_elements = [Line2D([0], [0], marker='o', markersize=8,color='blue', lw=0, label='Carbon Offset in 0 to 25-th percentile, PCC = '+corrs[0]),
                Line2D([0], [0],marker='o',  color='orange',markersize=8, lw=0, label='Carbon Offset in 25 to 50-th percentile, PCC = '+corrs[1]),
                Line2D([0], [0],marker='o',  color='green',markersize=8, lw=0, label='Carbon Offset in 50 to 75-th percentile, PCC = '+corrs[2]),
                Line2D([0], [0],marker='o',  color='red',markersize=8, lw=0, label='Carbon Offset in 75 to 100-th percentile, PCC = '+corrs[3])]
            
            plt.legend(handles=legend_elements, fontsize=fontsize*0.75)
        if title is None:
            plt.title(ylabel + " versus " + xlabel, fontsize=fontsize)
        else:
            plt.title(title, fontsize=fontsize)
        plt.tight_layout()
        plt.show()

# Creates a US map plot of the dat, edf should be provided, but if it isn't then it will be created as necessary using the zipcodes provided
def geo_plot(dat, color_scale, title, edf=None, zipcodes=None, colorbar_label="", size=20, save_dir_prefix=None):

    # This should basically never get called since we define edf below, but if you were to import this you'd have to make sure zipcodes are provided to create the edf
    if edf is None:
        if zipcodes is None:
            print("invalid Geo Plotting, you must include an EDF or zipcode list")
            return -1
        else:
            nomi = pgeocode.Nominatim('us')
            edf = pd.DataFrame()
            edf['Latitude'] = (nomi.query_postal_code(zipcodes).latitude)
            edf['Longitude'] = (nomi.query_postal_code(zipcodes).longitude)
            edf['zip_code'] = zipcodes

    # For scaling of the bar, we do 15 ticks over the range of the data
    dat_range = max(dat) - min(dat)
    edf['dat'] = dat
    clean_dat = edf.dropna(axis=0)

    fig = go.Figure(data=go.Scattergeo(
            lon = clean_dat['Longitude'],
            lat = clean_dat['Latitude'],
            mode = 'markers',
            marker = dict(
            color = clean_dat['dat'],
            colorscale = color_scale,
            reversescale = True,
            opacity = 0.7,
            size = size,
            colorbar = dict(
                # titleside = "right",
                x = 0.8,
                xpad = 200,
                outlinecolor = "rgba(68, 68, 68, 0)",
                ticks = "outside",
                showticksuffix = "last",
                dtick = dat_range/15,
                title=colorbar_label,
            )
            )))

    fig.update_layout(
            title = title,
            geo_scope='usa',
            font=dict(
            family="Courier New, monospace",
            size=36,
            color="Black",
        )
        )
    
    if save_dir_prefix is not None:
        fig.write_image(fig,save_dir_prefix + "Maps/" + title + '_by_zip.png', format='png', engine='kaleido')
    
    fig.show(renderer="browser")

def state_bar_plot(energy_gen_df, states=['Texas', 'Massachusetts', "California", 'New York', "US Total"], keys=['Clean', 'Bioenergy', 'Coal','Gas','Fossil','Solar','Hydro','Nuclear'], ylabel="Proportion of energy generation", title="Energy Generation Proportions by state", sort_by=None,stack=True,legend_loc="auto",fontsize=None, colors=None):

    if states is not None:
        # Removes all states besides those in the 'states' list
        energy_gen_df = energy_gen_df[energy_gen_df['State'].isin(states)]
        
    if sort_by is not None:
        energy_gen_df = energy_gen_df.sort_values(sort_by)

    # Drop Total Generation so it doesn't plot
    df =  energy_gen_df[keys + ['State code']]



    if states is None:
        df = pd.concat([df[:5], df[-5:]])

    # removing the _prop part of the column names
    sources = df.columns
    df.columns = ["".join(x.split("_prop")) for x in sources]

    # sns.barplot(data=energy_gen_df,x= 'State')

    #set seaborn plotting aesthetics
    sns.set(style='white')

    #create stacked bar chart
    ax = df.set_index('State code').plot(kind='bar', stacked=stack, fontsize=fontsize, color=colors)
    ax.set_xticklabels(df['State code'], rotation='horizontal') 

    if legend_loc == 'right':
        # Shrink current axis by 20%
        box = ax.get_position()
        ax.set_position([box.x0, box.y0, box.width * 0.8, box.height])

        # Put a legend to the right of the current axis
        ax.legend(loc='center left', bbox_to_anchor=(1, 0.5), fontsize=fontsize*2)

    handles, labels = ax.get_legend_handles_labels()
    ax.legend(handles[::-1], labels[::-1], title='', loc=legend_loc, ncol=len(keys))
    ax.set_ylim([0, 1.2])

    plt.xlabel("")
    plt.ylabel(ylabel)
    plt.title(title, fontsize=fontsize)
    plt.show()

def get_colorbrewer_palette(palette_name, bins):
    """
    Returns a list of hex color codes as strings from the given ColorBrewer palette.
    - palette_name: e.g. "Blues", "BuPu"
    - bins: int, number of colors
    """
    from branca.colormap import linear

    def to_hex_color(c):
        return '#{:02x}{:02x}{:02x}'.format(
            int(c[0]*255), int(c[1]*255), int(c[2]*255)
        )

    palette_name = palette_name.strip()
    
    # Try to find the closest available branca ColorBrewer colormap
    found = False
    possible_ns = list(range(bins, 2, -1)) + [9, 8, 7, 6, 5, 4, 3]
    for n in possible_ns:
        try:
            brewer = getattr(linear, f"{palette_name}_{str(n).zfill(2)}")
            base_colors = brewer.colors
            found = True
            break
        except AttributeError:
            continue

    if not found:
        brewer = linear.BuPu_09
        base_colors = brewer.colors

    # If we found the right number of bins, just return the palette (it should already be hex)
    if len(base_colors) == bins and isinstance(base_colors[0], str):
        return base_colors

    # Otherwise, interpolate using the colormap
    continuous = brewer.scale(0, 1)
    colors = [continuous(i/(bins-1)) for i in range(bins)]
    # If hex, leave as is; if tuple, convert to hex
    if isinstance(colors[0], str):
        return colors
    else:
        return [to_hex_color(c) for c in colors]

def plot_state_map(stats_df, key, fill_color="BuPu", zoom=4.8, location=[38,-96.5], legend_name=None, save_dir_prefix="", show=True):
    '''
    Plots a map of the US states with color intensity dependent on the attribute given by key
    '''
    url = (
        "https://raw.githubusercontent.com/python-visualization/folium/main/examples/data"
    )
    state_geo = f"{url}/us-states.json"

    m = fl.Map(location, zoom_start=zoom, zoom_control=False)

    if legend_name is None:
        legend_name = key

    fig = fl.Choropleth(geo_data=state_geo, data=stats_df,
    columns=['State code', key],key_on='feature.id', fill_color=fill_color, line_weight=1, fill_opacity=0.7, line_opacity=.5)
    
    for k in fig._children:
        if k.startswith('color_map'):
            del(fig._children[k])   

    fig.add_to(m)

    min_value = round(np.min(stats_df[key]), 2)
    max_value = round(np.max(stats_df[key]),2)
    palette = ["#f7fcfd","#e0ecf4","#bfd3e6","#9ebcda","#8c96c6","#8856a7","#810f7c"]
    palette = get_colorbrewer_palette(fill_color, bins=7)

    template = f"""
        {{% macro html(this, kwargs) %}}

        <!-- Title -->
        <div style="
            position: fixed;
            left: 50px;
            bottom: 90px;
            z-index:9999;
            font-size: 26px;
            font-family: 'DejaVu Sans', Arial, Helvetica, sans-serif;
            font-weight: bold;
            color: #222;
            background: rgba(255,255,255,0.85);
            padding: 5px 12px 2px 12px;
            border-radius: 8px 8px 0 0;
            border: 2px solid #AAA;
            border-bottom: none;
            box-shadow: 2px 2px 6px rgba(50,50,50,0.18);
            ">
        {legend_name}
        </div>

        <!-- Box and Colorbar -->
        <div style="
            position: fixed; 
            left: 50px; 
            bottom: 50px;
            width: 420px;
            height: 40px;
            background: white;
            border: 2px solid #aaa;
            border-radius: 0 0 10px 10px;
            z-index: 9998;
            display: flex;
            align-items: center;
            box-shadow: 2px 2px 6px rgba(50,50,50,0.18);
            padding: 0 0 0 0;
            opacity: 0.96;
        ">
            <span style="
                font-size: 18px;
                font-family: 'DejaVu Sans', Arial, Helvetica, sans-serif;
                color: #444;
                font-weight: bold;
                padding-left: 15px;
                padding-right: 10px;
                min-width: 45px;
                text-align: right;
                ">
            {min_value}
            </span>

            <svg width="320" height="22" style="margin: 0 10px; flex-shrink:1;">
            <defs>
                <linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="0%">
                <stop offset="0%"   stop-color="{palette[0]}" />
                <stop offset="16%"  stop-color="{palette[1]}" />
                <stop offset="33%"  stop-color="{palette[2]}" />
                <stop offset="50%"  stop-color="{palette[3]}" />
                <stop offset="66%"  stop-color="{palette[4]}" />
                <stop offset="83%"  stop-color="{palette[5]}" />
                <stop offset="100%" stop-color="{palette[6]}" />
                </linearGradient>
            </defs>
            <rect x="0" y="0" width="320" height="22" fill="url(#grad1)" stroke="#888" stroke-width="1"/>
            </svg>

            <span style="
                font-size: 18px;
                font-family: 'DejaVu Sans', Arial, Helvetica, sans-serif;
                color: #444;
                font-weight: bold;
                padding-right: 15px;
                padding-left: 10px;
                min-width: 45px;
                text-align: left;
                ">
            {max_value}
            </span>
        </div>
        {{% endmacro %}}
    """

    macro = MacroElement()
    macro._template = Template(template)
    m.get_root().add_child(macro)

    for k in m._children:
        if k.startswith('color_map'):
            del(m._children[k])


    img_data = m._to_png(5)
    img = Image.open(io.BytesIO(img_data))
    if save_dir_prefix is not None:
        img.save(save_dir_prefix + "Maps/" + key + '_by_state.png')

    if show:
        img.show()

    # m.show_in_browser()

def bar_plot_demo_split(df, demos, key, type="avg value", stacked=False, xticks=None, title=None, ylabel=None, annotate=True, hatches=None, legend=True):
    true_avg = np.mean(df[key].values)

    plt.style.use('seaborn-colorblind')

    font = {'family' : 'DejaVu Sans',
    'weight' : 'bold',
    'size'   : 20}

    matplotlib.rc('font', **font)

    new_df = pd.DataFrame()
    low_avgs = []
    high_avgs = []
    
    for demo in demos:
        median = np.median(df[demo].values)
        low_avg = np.mean(df[df[demo] < median][key].values)
        high_avg = np.mean(df[df[demo] >= median][key].values)

        if type == "percent":
            low_avg = ((low_avg/true_avg) - 1) * 100
            high_avg = ((high_avg/true_avg) -1) * 100
        if type == "diff":
            low_avg = true_avg - low_avg
            high_avg = true_avg - high_avg
        if type == 'paper':
            low_avg /= true_avg
            high_avg /= true_avg

        low_avgs.append(low_avg)
        high_avgs.append(high_avg)
       
    new_df['demographic'] = demos
    new_df['Below median'] = low_avgs
    new_df['Above median'] = high_avgs


    print(new_df)
    ax = new_df.set_index('demographic').plot(kind='bar', stacked=stacked, width=0.8)

    if hatches is not None:
        bars = ax.patches

        for bar, hatch in zip(bars, hatches):
            bar.set_hatch(hatch)
    

    ymin, ymax = ax.get_ylim()

    if type == "paper":
        plt.ylim(ymin, ymax*1.2)
        ymax *= 1.2

    plt.vlines((ax.patches[0].get_width() * (50/8)), ymin/2, ymax/2, colors=['grey'], linestyles='dotted', linewidth=3)
    plt.vlines((ax.patches[0].get_width() * (70/8)), ymin/2, ymax/2, colors=['grey'], linestyles='dotted', linewidth=3)

    if annotate:
        for p in ax.patches:
            ax.annotate(str(np.round(p.get_height(), 1)), (p.get_x() + p.get_width()/7 - ((p.get_height() < 0) * 0.01) , p.get_height() / 2 ))

    if type == "percent":
        true_avg = 0
    if type == "diff":
        true_avg = 0
    if type == 'paper':
        true_avg = 1

    # plt.tight_layout(pad=1.08)
    plt.axhline(y=true_avg, color='k', linestyle='--', label="National Average",linewidth=5)
    plt.xlabel("")
    plt.yticks(fontsize=30)
    plt.xticks(fontsize=30)
    if legend:
        plt.legend(ncol=3, fontsize=26)
    else:
        ax.legend(handles=[], labels= [])
        plt.legend([])

    if title is not None:
        plt.title(title)
    else:
        plt.title("demographic relationship to " + key + " by " + type)
    if ylabel is not None:
        plt.ylabel(ylabel, labelpad=20, fontdict={'family' : 'DejaVu Sans',
    'weight' : 'bold',
    'size'   : 25})
    else:
        plt.ylabel(key)
    if xticks is not None:
        ax.set_xticklabels(xticks, rotation='horizontal')    
    plt.show()

def plot_state_stats(stats_df, key, states=None, sort_by='mean'):

    if states is not None:
        # Removes all states besides those in the 'states' list
        stats_df = stats_df[stats_df['state_name'].isin(states)]

    stats_df = stats_df.sort_values(sort_by)

    if states is None:
        stats_df = pd.concat([stats_df[:5], stats_df[-5:]])

    stats_df.set_index('State code').plot(kind='bar', stacked=False)

    plt.ylabel(key)

    title_add = ""
    if key in ['solar_utilization', 'carbon_offset_metric_tons','existing_install_count']:
        title_add = " per capita"


    plt.title("States sorted by "+ sort_by +" of "+ key+ title_add +" -- (bottom and top 5)")
    plt.legend()
    plt.show()

# Gets the pareto-optimal elements of eval_df over 2 objectives obj1 and obj2
def get_pareto_subset(eval_df, obj1, obj2, save=None, load=None):

    if load is not None and os.path.exists(load):
        return pd.read_csv(load)

    p_optimal_df = pd.DataFrame.copy(eval_df)

    for eval_index, row in tqdm(list(eval_df.iterrows())):
        # p_optimal_df = pd.concat([row, p_optimal_df], axis=1, ignore_index=True)


        for opt_index, in_opt in p_optimal_df.iterrows():

            if in_opt[obj1] < row[obj1] and in_opt[obj2] < row[obj2]:
                p_optimal_df.drop(opt_index, inplace=True)

    if save is not None:
        p_optimal_df.to_csv(save)
    
    return p_optimal_df

# Creates a pareto-front plot based on 2 objectives stored in eval_df
# others are other strategies to plot alongside the main bulk for comparison
def create_pareto_front_plots(eval_df, obj1, obj2, fit=2, others=[], scale={'Carbon Offset': 1, 'Energy Generation':1, 'Racial Equity':1, 'Income Equity':1}, load=None):
    
    pareto_optimal_df = get_pareto_subset(eval_df, obj1, obj2, save=load, load=load)
    pareto_optimal_df = pareto_optimal_df.sort_values(obj1, inplace=False, ignore_index=True) # so they plot in order from lowest to highest x value

    ax = plt.gca()

    xmin = np.min(np.append(eval_df[obj1], others[0][obj1]))/scale[obj1] * 0.9
    xmax = np.max(np.append(eval_df[obj1], others[0][obj1]))/scale[obj1] * 1.1
    ymin = np.min(np.append(eval_df[obj2], others[0][obj2]))/scale[obj2] * 0.9
    ymax = np.max(np.append(eval_df[obj2], others[0][obj2]))/scale[obj2] * 1.1

    s = int((1.8*2)**4)

    ax.set_xlim([xmin, xmax])
    ax.set_ylim([ymin, ymax])

    xmin=np.min(eval_df.values)
    ymax=np.max(eval_df.values)

    # plt.vlines(1, ymin, ymax, colors=['gray'], linestyles='dashed', linewidth=3, label=scale['label'], zorder = -1, alpha =0.5)
    plt.vlines(1, ymin, ymax, colors=['gray'], linestyles='dashed', linewidth=3, zorder = -1, alpha =0.5)
    plt.hlines(1, xmin, xmax, colors=['gray'], linestyles='dashed', linewidth=3, zorder = -1, alpha =0.5)

    plt.scatter(eval_df[obj1]/scale[obj1], eval_df[obj2]/scale[obj2], color='orange', label='All Linear Weights', s=s, alpha=0.3, zorder=0)
    plt.xlabel(obj1 + " (Ratio to "+scale['label']+")", labelpad=10, fontsize=15)
    plt.ylabel(obj2 + " (Ratio to  "+scale['label']+")", labelpad=10, fontsize=15)

    plt.plot(pareto_optimal_df[obj1]/scale[obj1], pareto_optimal_df[obj2]/scale[obj2], marker='o', markersize=s/(2**4), label='Pareto Optimal Weights', linewidth=5)
    
    # This block will fit the selected polynomial to the pareto optimal solutions and plot them
    if fit is not None:
        coeff = np.polynomial.polynomial.Polynomial.fit(pareto_optimal_df[obj1]/scale[obj1], pareto_optimal_df[obj2]/scale[obj2], fit).convert().coef
        left = np.linspace(xmin, min(pareto_optimal_df[obj1]/scale[obj1]), 50)
        between = np.linspace(min(pareto_optimal_df[obj1]/scale[obj1]), max(pareto_optimal_df[obj1]/scale[obj1]), 50)
        right = np.linspace(max(pareto_optimal_df[obj1]/scale[obj1]), xmax, 50)
        left_pred = np.zeros(left.shape)
        right_pred = np.zeros(right.shape)
        bet_pred = np.zeros(between.shape)
        for i in range(fit + 1):
            left_pred += coeff[i] * (left ** i)
            right_pred += coeff[i] * (right ** i)
            bet_pred += coeff[i] * (between ** i)

        plt.plot(left, left_pred, linewidth=5, label="Estimated Pareto Frontier", color='blue', linestyle='dashed', alpha=0.5)
        plt.plot(between, bet_pred, linewidth=5, color='blue', linestyle='dashed', alpha=0.2)
        plt.plot(right, right_pred, linewidth=5, color='blue', linestyle='dashed', alpha=0.5)

    for other in others:
        plt.scatter(other[obj1]/scale[obj1], other[obj2]/scale[obj2], s=s*1.3, marker='X', color=other['color'], label=other['label'], zorder = 100, edgecolors='black')

    plt.legend()
    plt.tight_layout()
    plt.show()

def plot_projections(projections:list, objective:str="Carbon Offset", panel_estimations=None, net_zero_horizontal=False, fontsize=30, fmts=["-X", "-H", "o-", "D-", "v-", "-8", "-p"], ylabel=None, save_dir_prefix=None, show=True, save_name=None, **kwargs):

    # Some default sizing and styling
    plt.style.use('seaborn-v0_8')
    font = {'family' : 'DejaVu Sans',
    'weight' : 'bold',
    'size'   : fontsize}
    matplotlib.rc('font', **font)

    # Adds a horizontal line at the point where Status-Quo is expected to be when net-zero carbon emissions (479000 * 3 panels) is reached.
    if net_zero_horizontal and 'Status-Quo' in projections:
        two_mill_continued = np.array(projections['Status-Quo'])[479000 * 3]

    ax = plt.subplot()
    for projection, marker in zip(projections, fmts):
        projection.add_proj_to_plot(ax=ax, objective=objective, **kwargs)

    plt.locator_params(axis='x', nbins=8) 
    plt.locator_params(axis='y', nbins=8) 
    plt.yticks(fontsize=fontsize/(1.2))
    plt.xticks(fontsize=fontsize/(1.2))

    # get ranges of the plots axes
    xmin, xmax, ymin, ymax = plt.axis()

    ''' TODO test'''
    if panel_estimations is not None:
        for label, value in panel_estimations:
            plt.vlines(value, ymin+ymax/18, ymax, colors='darkgray' , linestyles='dashed', linewidth=2, alpha=0.7)
            plt.text(value - (xmax-xmin)/23, ymin + ymax/80, label, alpha=0.7, fontsize=25)
    
    if net_zero_horizontal:
        plt.hlines(two_mill_continued, 0, xmax, colors='black' , linestyles='dashed', linewidth=2, alpha=0.5)
        plt.text(0, two_mill_continued*1.1, "Continued trend at\nNet-zero prediction", alpha=0.95, fontsize=18, color='black')

    

    plt.xlabel("Additional Panels Built", fontsize=fontsize, labelpad=20)
    if ylabel is None:
        plt.ylabel(objective, fontsize=fontsize, labelpad=20)
    else:
        plt.ylabel(ylabel, fontsize=fontsize, labelpad=20)

    plt.legend(fontsize=fontsize/1.5)
    # plt.legend(loc='center left', bbox_to_anchor=(1, 0.5),
    #       ncol=1, shadow=True, fontsize=fontsize/1.4)
    plt.tight_layout()
    if show:
        plt.show()

    if save_dir_prefix is not None:
        plt.savefig(save_dir_prefix+"Simulation/Projection_Plots/"+save_name+'.png')



